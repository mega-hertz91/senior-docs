---
title: "Объекты первого класса"
---

## Объекты первого класса

В языках программирования существует понятие "объекты первого рода (или класса)". Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и присвоены переменным (или константам). К таким элементам относятся любые данные, например числа, строки, массивы или логические значения.

```
// 5 — число, объект первого рода (сохранено в константе)
const num = 5;

// 2 — число, объект первого рода (аргумент функции)
// содержимое константы num — объект первого рода (аргумент функции)
// содержимое константы result — объект первого рода (возвращаемое значение)
const result = Math.pow(num, 2);
```

Объектами первого рода может быть не только то, что мы привыкли именовать словом "данные", но и любая конструкция языка, например, функции. В JavaScript функции это объекты первого рода. Такая особенность очень серьезно влияет не только на обращение с функциями, но и на общий стиль программирования. Ниже мы поговорим об обращении с функциями как с данными.

## Сохранение в константе

```
// Функция записывается в константу!
const x = () => console.log('I love Hexlet');

x(); // => 'I love Hexlet'
```

В этом коде больше действий чем мы привыкли думать:

- Создание (определение) функции: () => console.log('I love Hexlet')
- Создание константы x и сохранение в ней значения в виде функции: const x =
Этот момент нужно хорошо прочувствовать. Минимальное определение функции, которое только возможно, выглядит так: () => {}. Это пустая функция с пустым телом, которая не делает ничего. Присваивать её константе или нет — вопрос отдельный.

Даже сохранив функцию внутри константы, ничего не мешает передать ее в другую константу. Только не забывайте об объектной природе функции. В другую константу передается не сама функция, а ссылка на нее:

```
const a = () => console.log('I love Hexlet');

a(); // => 'I love Hexlet'

const b = a;

b(); // => 'I love Hexlet'
```

Более того, любую функцию можно использовать напрямую, без сохранения в константе:

```
(() => console.log('I love Hexlet'))(); // => I love Hexlet
```

В примере мы сделали вызов функции, что называется, "на лету": сначала создали (() => console.log('I love Hexlet')) и сразу же сделали вызов с помощью оператора вызова функции (). При этом определение функции следует обернуть в круглые скобки, чтобы обозначить границы определения для интерпретатора, которому нужно "понимать", что конкретно вы хотите вызвать. Понятно, что после такого выражения доступ к функции будет утерян, потому что она нигде не была сохранена.

Имя константы – это лишь её имя, а сама функция не имеет имени. Поэтому такие функции в программировании принято называть "анонимными". В других языках анонимные функции нередко называют лямбда-функциями. В JavaScript их иногда зовут так же.

## Создание внутри другой функции

Раз анонимная функция — выражение, мы можем определять её в любом месте программы, допускающем использование выражений, например, в теле другой функции!

```
const sum = (a, b) => {
  // определили "внутреннюю" анонимную функцию и
  // сохранили в константе innerSum
  const innerSum = (x, y) => x + y;

  // вызвали внутреннюю функцию и
  // вернули результат вызова наружу из sum
  return innerSum(a, b);
};

sum(1, 4); // 5
```

Из того факта, что определение функции является обыкновенным выражением, следует, что её можно передавать в другие функции в качестве аргументов и возвращать из других функций, как значения. Подробнее поговорим об этом, когда будем изучать функции высшего порядка.

Использование анонимных функций значительно повышает выразительные возможности языка, и в этом вы скоро убедитесь. В JavaScript анонимные функции составляют костяк любой программы. Функции, создающие функции, возвращающие функции и принимающие функции как аргументы — основной способ разрабатывать в JavaScript.