---
title: 'Логика'
---

## Логика

Языки программирования адаптировали все математические операции сравнения практически в неизменном виде. Единственное серьезное отличие – операторы равенства и неравенства. В математике для этого используется обычное равно =, но в программировании такое встречается не часто. Во многих языках символ = используется для присваивания значений переменным, поэтому для сравнения взяли == или ===.

Список операций сравнения в JavaScript:

- ```< меньше```
- ```<= меньше или равно```
- ```> больше```
- ```>= больше или равно```
- ```=== равно```
- ```!== не равно```    

 ## Логический тип

 Логическая операция типа 5 > 4 или password === text — это выражение, и его результат — специальное значение true («истина») или false («ложь»). Это новый для нас тип данных — boolean.
 
 ```
 const result = 5 > 4;
 console.log(result); // => true
 console.log('one' !== 'one'); // => false
```

## Комбинирование логических операций

Логические операции — это выражения. Значит, логические операции можно комбинировать с другими выражениями.

Например, мы хотим проверить четность числа, то есть кратность двум. В программировании используют такой подход:

- проверяют остаток от деления на 2:
- если остаток 0, то число было четным
- если остаток не 0, то число было нечетным

Остаток от деления — простая, но очень важная концепция в арифметике, алгебре, и даже в теории чисел и криптографии. Идея проста: нужно разделить число на несколько равных групп, и если в конце что-то останется — это и есть остаток от деления.

Делим конфеты поровну между людьми:

- 7 конфет, 2 человека: 2 x 3 + остаток 1. Значит, 7 не кратно 2.
- 21 конфету, 3 человека: 3 x 7 + остаток 0. Значит, 21 кратно 3.
- 19 конфет, 5 человек: 5 x 3 + остаток 4. Значит, 19 не кратно 5.

```
// функция проверки четности
const isEven = (number) => number % 2 === 0;

isEven(10); // true
isEven(3);  // false
```

В одном выражении мы скомбинировали логический оператор === (проверка равенства) и арифметический оператор %.

Приоритет **арифметических операций выше логических**. Значит, сначала вычисляется арифметическое выражение number % 2, затем результат участвует в логическом сравнении.

Словами это можно расшифровать так: «вычислить остаток от деления числа number на 2 и сравнить, равен ли остаток нулю; затем вернуть результат проверки равенства».

## Логические операторы 

Логические выражения могут объединяться друг с другом, создавая все более хитрые проверки. Хороший пример: проверка пароля. Как вы знаете, некоторые сайты при регистрации хотят пароль от 8 до 20 символов в длину. Честно говоря, это странное ограничение, но что поделать. В математике мы бы написали 8 < x < 20 (где x это длина конкретного пароля), но в JavaScript такой трюк не пройдет. Нам придется сделать два отдельных логических выражения и соединить их специальным оператором «И»:

Вот функция, которая принимает пароль и говорит, соответствует ли он условиям, или не соответствует:

```
const isStrongPassword = (password) => {
  const length = password.length;
  return length > 8 && length < 20;
};

isStrongPassword('qwerty'); // false
isStrongPassword('qwerty1234'); // true
isStrongPassword('zxcvbnmasdfghjkqwertyui'); // false
```

&& - означает «И» (в математической логике это называют конъюнкцией). Все выражение считается истинным только в том случае, когда истинен каждый операнд — каждое из составных выражений. Иными словами, && означает «и то, и другое».

Приоритет этого оператора ниже, чем приоритет операторов сравнения, поэтому выражение отрабатывает правильно без скобок.

Кроме &&, часто используется оператор || — «ИЛИ» (дизъюнкция). Он означает «или то, или другое, или оба». Операторы можно комбинировать в любом количестве и любой последовательности, но когда одновременно встречаются && и ||, то приоритет лучше задавать скобками. Ниже пример расширенной функции определения корректности пароля:

### И && (Конъюкция)

|A	  |B      |A && B |
|-----|-------|-------|
|TRUE |	TRUE  |	TRUE  |
|TRUE |	FALSE |	FALSE |
|FALSE|	TRUE  |	FALSE |
|FALSE|	FALSE |	FALSE |

Принцип все или ничего

```
// true && true;
3 > 2 && 'wow'.startsWith('w'); // true

// true && false;
'start' === 'start' && 8 < 3; // false
```

### ИЛИ || (Дизъюкция)

|A	  |B      |A && B |
|-----|-------|-------|
|TRUE |	TRUE  |	TRUE  |
|TRUE |	FALSE |	TRUE  |
|FALSE|	TRUE  |	TRUE  |
|FALSE|	FALSE |	FALSE |

Принцип если хотя бы кто-нибудь

```
// false || true;
3 < 2 || 'wow'.startsWith('w'); // true

// false || false;
'start' === 'Start' || 3 < 3; // false
```

### Отрицание

```
const isEven = (number) => number % 2 === 0;

isEven(10);  // true  Четное ли
!isEven(10); // false  Нечетное ли
!isEven(11) // true  Нечетное ли
!!isEven(10) // true // Четное ли + приведение типа к boolean
```

## Условные конструкции 

- if
- else
- Конструкция else if

```
const getTypeOfSentence = (sentence) => {
  const lastChar = sentence[sentence.length - 1];
  let sentenceType;

  if (lastChar === '?') {
    sentenceType = 'question';
  } else if (lastChar === '!') {
    sentenceType = 'exclamation';
  } else {
    sentenceType = 'normal';
  }

  return `Sentence is ${sentenceType}`;
};

getTypeOfSentence('Who?'); // Sentence is question
getTypeOfSentence('No');   // Sentence is normal
getTypeOfSentence('No!');  // Sentence is exclamation
```

Теперь все условия выстроены в единую конструкцию. else if — это «если не выполнено предыдущее условие, но выполнено текущее». Получается такая схема:

если последний символ это ?, то 'question'
иначе, если последний символ это !, то 'exclamation'
иначе 'normal'

## Тернарный оператор

Тернарный оператор — единственный в своем роде оператор, требующий три операнда:

```
const abs = (number) => {
  return number >= 0 ? number : -number;
};
```

## Результат логических операций

Посмотрите на код ниже и попробуйте угадать, что будет напечатано на экран:

```console.log(0 || 1);```
Правильный ответ: 1

Оператор ИЛИ работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в true. Если первый аргумент невозможно преобразовать в true, то возвращается второй, даже если его нельзя преобразовать в true.

Ниже пример с оператором И:

```console.log(0 && 1); // => 0```
Оператор И работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в false.

В JavaScript есть два простых правила, по которым происходят преобразования:

::list{type="primary"}
- 0, 
- '' (пустая строка),
- undefined,
- NaN, 
- null 
::

:badge[Приводятся к false.]{type="warning"}

Эти значения называют falsy.
Все остальное приводится к true
Этим активно пользуются в разработке, например, для определения значения по умолчанию:

```
const value = name || '';
// Примеры
234 || ''; // 234
'hexlet' || ''; // hexlet
undefined || ''; // ''
```